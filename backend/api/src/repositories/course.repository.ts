import type { Collection, OptionalUnlessRequiredId, WithId } from "mongodb";
import { ObjectId } from "mongodb";
import type {
  CourseDocument,
  CourseStatus,
  CreateCourseInput,
  UpdateCourseInput,
} from "../models/course.model.js";
import { getCollection } from "../services/database.js";

type CourseWithId = WithId<CourseDocument>;

function coursesCollection(): Collection<CourseDocument> {
  return getCollection<CourseDocument>("courses");
}

export async function createCourse(
  input: CreateCourseInput
): Promise<CourseDocument> {
  const now = new Date();
  const doc: Omit<CourseDocument, "_id"> = {
    slug: input.slug,
    title: input.title,
    languageId: input.languageId,
    languageKey: input.languageKey,
    description: input.description,
    levels: input.levels ?? [],
    autoGenerated: input.autoGenerated ?? false,
    meta: input.meta,
    status: input.status ?? "draft",
    createdAt: now,
    updatedAt: now,
    publishedAt: input.publishedAt ?? undefined,
  };

  const result = await coursesCollection().insertOne(
    doc as OptionalUnlessRequiredId<CourseDocument>
  );

  return {
    _id: result.insertedId,
    ...doc,
  };
}

export async function findCourseById(
  id: string | ObjectId
): Promise<CourseDocument | null> {
  const objectId = typeof id === "string" ? new ObjectId(id) : id;
  return coursesCollection().findOne({ _id: objectId });
}

export async function findCourseBySlug(
  slug: string
): Promise<CourseDocument | null> {
  return coursesCollection().findOne({ slug });
}

export async function findPublishedCourses(): Promise<CourseDocument[]> {
  return coursesCollection()
    .find({ status: "published" satisfies CourseStatus })
    .sort({ createdAt: -1 })
    .toArray();
}

export async function findCoursesByIds(
  ids: ObjectId[]
): Promise<CourseDocument[]> {
  if (ids.length === 0) return [];
  return coursesCollection()
    .find({ _id: { $in: ids } })
    .toArray();
}

export async function updateCourseById(
  id: ObjectId,
  update: UpdateCourseInput
): Promise<CourseDocument | null> {
  const $set: Partial<CourseDocument> = {
    updatedAt: new Date(),
  };

  if (update.title !== undefined) {
    $set.title = update.title;
  }

  if (update.description !== undefined) {
    $set.description = update.description ?? undefined;
  }

  if (update.levels !== undefined) {
    $set.levels = update.levels;
  }

  if (update.languageKey !== undefined) {
    $set.languageKey = update.languageKey;
  }

  if (update.autoGenerated !== undefined) {
    $set.autoGenerated = update.autoGenerated;
  }

  if (update.meta !== undefined) {
    $set.meta = update.meta;
  }

  if (update.status !== undefined) {
    $set.status = update.status;
  }

  if (update.publishedAt !== undefined) {
    $set.publishedAt = update.publishedAt ?? undefined;
  }

  const result = await coursesCollection().findOneAndUpdate(
    { _id: id },
    { $set },
    { returnDocument: "after" }
  );

  return result ?? null;
}

export async function addTopicsToLevel(
  courseId: ObjectId,
  levelName: string,
  topicIds: ObjectId[]
): Promise<CourseWithId | null> {
  const now = new Date();
  const result = await coursesCollection().findOneAndUpdate(
    { _id: courseId, "levels.name": levelName },
    {
      $addToSet: {
        "levels.$.topicIds": { $each: topicIds },
      },
      $set: {
        updatedAt: now,
      },
    },
    { returnDocument: "after" }
  );

  if (result) {
    return result;
  }

  const created = await coursesCollection().findOneAndUpdate(
    { _id: courseId, "levels.name": { $ne: levelName } },
    {
      $push: {
        levels: {
          name: levelName,
          topicIds,
        },
      },
      $set: {
        updatedAt: now,
      },
    },
    { returnDocument: "after" }
  );

  return created ?? null;
}
